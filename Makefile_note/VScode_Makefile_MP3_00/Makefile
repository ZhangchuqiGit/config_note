
.PHONY: all clean # .PHONY 表示是个伪目标

CFLAGS += -Wall -std=c11 # make_debug

Sources = $(wildcard *.c) # 通配符会被自动展开
Objects = $(Sources:.c=.o)

all: mp3

mp3:$(Objects)
	@echo "Sources =$(Sources)"
	@echo "Objects =$(Objects)"
	$(CC) -o $@ $^

%.o:%.c
	$(CC) -o $@ -c $^

clean:
	rm -f mp3 $(Objects)



###################################################### 

###################### 规则 #######################
# 0.make 默认用 /bin/sh 执行 /bin/make

# 1.一般规则：
# 目标：依赖
# 	command 命令（如 shell）
# ----------------- 
# 目标01 ... 目标06 ... ：依赖01 ... 依赖06 ... 
# 	command 命令（如 shell）
# -----------------
# 目标：依赖01 ...；command
# 	command 命令（如 shell）
# -----------------
# $(变量):匹配目标：匹配依赖
# 	command 命令（如 shell）
# 如 
# 	$(objects):%.o:%.cpp # 第2个 % 就是第一个 % 所指向
# 		$(CXX) -c $(CXXFLAGS) $< -o $@
# 等价于
# 	foo.o:foo.cpp
# 		$(CXX) -c $(CXXFLAGS) foo.cpp -o foo.o
# 	bbb.o:bbb.cpp
# 		$(CXX) -c $(CXXFLAGS) bbb.cpp -o bbb.o
# -----------------
# %.o:%.cpp
# 	command 命令（如 shell）

# 2.命令 command 格式：TAB键+命令（如 shell）
# 3.变量：字符串类型，同 shell
# 4.引用/导入其它文件（命令）：空格+include<Makefile文件名/shell文件名>
# 5.'-'+命令：减号，无论什么错误，不报错且继续运行
# 6.make -f Makefile文件名
# 7.make -C 目录/路径名

# 8.通配符：
# 	* 
# 	?  
# 	% 

# 9.通常， make 会把其要执行的命令行在命令执行前输出到屏幕上。当我们用 @ 字符在命令行前，那么，这个命令将不被 make 显示出来
# 	@echo 正在编译 XXX 模块......	（内容）
# 当 make 执行时，会输出“正在编译 XXX 模块……”字串，但不会输出命令，如果没有“@”，那么， make 将输出:
# 	echo 正在编译 XXX 模块...... 	(命令)
# 	正在编译 XXX 模块				（内容）
# 如果 make 执行时，带入 make 参数 -n 或 --just-print ，那么其只是显示命令，但不会执行命令，
# 这个功能很有利于我们调试我们的 Makefile，看看我们书写的命令是执行起来是什么样子的或是什么顺序的。
# 而 make 参数 -s 或 --silent 或 --quiet 则是全面禁止命令的显示。

###################### 变量 #######################
# 变量引用 $(CC) 或 ${CC}
# 变量子内容/部分引用 $(CC *.cpp) 
# 变量定义 CC = gcc （延迟展开赋值，可先定义后赋值）

# 延迟展开赋值 = 在运行阶段，实际使用变量时再进行求值
# 立即展开赋值 := 在解析阶段直接赋值常量字符串
# 注意事项：
#	一般 立即展开变量(:=) 用在目标和目标依赖中，而 延迟展开变量(=) 用在命令中。
#	一般变量默认为全局变量；目标变量在该目标所依赖的规则中都可以使用；自动变量是局部变量。

# 追加赋值 +=
# 条件赋值 ?= 若变量没有被定义过，则赋值。

###################### 自动变量 #######################
# $@ : 表示规则中的所有目标。在模式规则中，如果有多个目标，那么，$@ 就是匹配于目标中模式定义的集合。
# $% : 仅当目标是函数库文件中，表示规则中的目标成员名。
# 	例如，foo.a:bar.o，那么，$% 就是 bar.o ，$@ 就是 foo.a 。
# 	如果目标不是函数库文件（Unix 下是 .a ，Windows 下是 .lib ），那么，其值为空。

# $< : （每次使用）依赖目标中的第一个目标名字。如果依赖目标是以模式（即 % ）定义的，那么 $< 将是符合模式的一系列的文件集。注意，其是一个一个取出来的。
# $? : 所有比目标新的依赖目标的集合。以空格分隔。

# $^ : (所有目标依赖)所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那么这个变量会去除重复的依赖目标，只保留一份。
# 为了避免产生不必要的麻烦，我们最好给 $ 后面的那个特定字符都加上圆括号，比如，$(<) 就要比 $< 要好一些。

# $+ : 这个变量很像 $^ ，也是所有依赖目标的集合。只是它不去除重复的依赖目标。

# $* : 这个变量表示目标模式中 % 及其之前的部分。
# 如果目标是 dir/a.foo.b ，并且目标的模式是 a.%.b ，那么，$* 的值就是 dir/a.foo 。
# 如果目标中没有模式的定义，那么 $* 也就不能被推导出，
# 但是，如果目标文件的后缀是 make 所识别的， 那么 $* 就是除了后缀的那一部分。
# 例如：如果目标是 foo.c ，因为 .c 是 make 所能识别的后缀名，所以，$* 的值就是 foo 。
# 这个特性是 GNU make 的，很有可能不兼容于其它版本的 make，
# 所以，你应该尽量避免使用 $* ，除非是在隐含规则或是静态模式中。
# 如果目标中的后缀是 make 所不能识别的，那么 $* 就是空值。

# 这7个自动化变量还可以取得文件的目录名或是在当前目录下的符合模式的文件名，只需要搭配上 D 或 F 字样。
# 这是 GNU make 中老版本的特性，在新版本中，我们使用函数 dir 或 notdir 就可以做到了。
# D 的含义就是 Directory，就是目录，F 的含义就是 File，就是文件。
# $(@D)  表示 $@ 的目录部分（不以斜杠作为结尾），如果 $@ 值是 dir/foo.o ，那么 $(@D) 就是 dir ，而如果 $@ 中没有包含斜杠的话，其值就是 . （当前目录）。
# $(@F) 表示 $@ 的文件部分，如果 $@ 值是 dir/foo.o ，那么 $(@F) 就是 foo.o ，$(@F) 相当于函数
# $(notdir $@) 。
# $(*D), $(*F) 和上面所述的同理，也是取文件的目录部分和文件部分。对于上面的那个例子，$(*D)  返回 dir ，而 $(*F) 返回 foo
# $(%D), $(%F) 分别表示了函数包文件成员的目录部分和文件部分。这对于形同 archive(member) 形式的目标中的 member 中包含了不同的目录很有用。
# $(<D), $(<F) 分别表示依赖文件的目录部分和文件部分。
# $(^D), $(^F) 分别表示所有依赖文件的目录部分和文件部分。（无相同的）
# $(+D), $(+F) 分别表示所有依赖文件的目录部分和文件部分。（可以有相同的）
# $(?D), $(?F) 分别表示被更新的依赖文件的目录部分和文件部分。

# 注意的是，这些变量只使用在规则的命令中，而且一般都是“显式规则”和“静态模式规则”（参见前面“书写规则”一章）。其在隐含规则中并没有意义。

###################### 变量的 Makefile 之间传递 #######################
#	Makefile 在多目录下递归执行 $(MAKE) –C <子目录> 或 cd <子目录> && $(MAKE)
#	通过 关键字 export/unexport 在 Makefile 之间传递变量 export/unexport <变量名>
#	通过 命令行 传递变量

# 若修改 make 传递进来的变量值，用 关键字 override 声明

###################### 隐含规则 #######################
# make 默认将 .c 文件编译成对应的 .o 目标文件；
# 对没有命令行的规则，寻找一个隐含的规则来执行；
# 取消隐含规则，使用-r 或-R参数取消隐含规则。
# 隐含变量/系统环境变量
#	作用范围：变量在 make 开始运行时被载入到 Makefile 文件中，对所有的 Makefile 都有效。
#	若 Makefile 中定义 同名变量，系统环境变量将被覆盖；命令行中传递同名变量，系统环境变量将被覆盖。
#	隐含变量：命令变量
#		CC：编译程序，默认是 $(CC)=cc
#		AS：汇编程序，默认是 $(AS)=as
#		CXX：C++编译程序，默认 $(CXX)=g++
#		AR：函数库打包程序，默认是 $(AR)=ar
#	隐含变量：命令参数变量
#		CFLAGS：执行CC编译器的命令行参数
#		CXXFLAGS：执行g++编译器命令行参数
#		ASFLAGS：执行汇编器AS命令行参数
#		ARFLAGS：执行AR命令行参数
#		更多参数：LDFLAGS、CPPFLAGS

###################### 模式规则 #######################
# 使用模式规则来定义一个隐式规则；
# 模式规则，至少在规则的目标定义中包含 %（任意长度的非空字符串，表示对文件名的匹配）；
# 在目标文件名中，% 匹配的部分称为“茎”；
# 目标和目标依赖同时含有 %，依赖目标的茎会传给目标；
# 普通多目标规则：每个目标作为一个独立规则处理；多个目标对应多个独立规则。
# 多目标模式规则：同一个模式规则可以存在多个目标，所有规则目标共同拥有依赖文件和规则的命令行，
#	当文件符合多个目标模式中的任何一个时，规则定义的命令执行

###################### 条件 #######################
# 命令包：
# define <命令包名字>
# 	command 命令（如 shell）
# endef

# 条件执行 关键字 
# ifeq/ifneq (条件1,条件2)
# else
# endif
# ----------------------------
# ifeq/ifneq (条件1,) # 如果为空

# 若果已/未定义 关键字 
# ifdef/ifndef 变量名
# else
# endif
# ----------------------------
# ifneq 变量名 # 如果为空

###################### shell 函数 #######################
# shell 函数也不像其它的函数。顾名思义，它的参数应该就是操作系统 Shell 的命令。
# 它和反引号“‘”是相同的功能。这就是说， shell 函数把执行操作系统命令后的输出作为函数返回。
# 于是，我们可以用操作系统命令以及字符串处理命令 awk， sed 等等命令来生成一个变量，如：
# 	contents := $(shell cat foo)
# 	files := $(shell echo *.c)
# 注意，这个函数会新生成一个 Shell 程序来执行命令，所以你要注意其运行性能，如果你的 Makefile
# 中有一些比较复杂的规则，并大量使用了这个函数，那么对于你的系统性能是有害的。
# 特别是 Makefile的隐晦的规则可能会让你的 shell 函数执行的次数比你想像的多得多。

###################### 字符串处理函数 #######################
# $(subst <from>,<to>,<text>) 
# 名称：字符串替换函数
# 功能：把字串 <text> 中的 <from> 字符串替换成 <to> 。
# 返回：函数返回被替换过后的字符串。不修改 <test>。
# 示例：$(subst ee,EE,feet on the street)
# 把 feet on the street 中的 ee 替换成 EE ，返回结果是 fEEt on the strEEt 。

# $(patsubst <pattern>,<replacement>,<text>)
# 名称：模式字符串/单词 替换函数。
# 功能：查找 <text> 中的单词（单词以“空格”、“Tab”或“回车”“换行”分隔）是否符合模式<pattern> ，如果匹配的话，则以 <replacement> 替换。
# 这里，<pattern> 可以包括通配符 % ， 表示任意长度的字串。
# 如果 <replacement> 中也包含 % ，那么，<replacement> 中的这个 % 将是<pattern> 中的那个 % 所代表的字串。
# （可以用 \ 来转义，以 \% 来表示真实含义的 % 字符）
# 返回：函数返回被替换过后的字符串。不修改 <test>。
# 示例：$(patsubst %.c,%.o,x.c.c bar.c)
# 把字串 x.c.c bar.c 符合模式 %.c 的单词替换成 %.o ，返回结果是 x.c.o bar.o
# $(var:<pattern>=<replacement>)(修改 <var>) 相当于 $(patsubst <pattern>,<replacement>,$(var))
# $(var:<suffix>=<replacement>)(修改 <var>)  相当于 $(patsubst %<suffix>,%<replacement>,$(var)) 
# 例如有:objects = foo.o bar.o baz.o，
# 那么，$(objects:.o=.c) 和 $(patsubst %.o,%.c,$(objects)) 是一样的。

# make 使用 VPATH  变量来指定“依赖文件”的搜索路径。
# 如果我们的 $(VPATH) 值是 src:../headers ，那么 $(patsubst %,-I%,$(subst :, ,$(VPATH)))
# 将返回 -Isrc -I../headers ，这正是 cc 或 gcc 搜索头文件路径的参数。

# $(strip <string>)
# 名称：去空格函数。
# 功能：去掉 <string> 字串中开头和结尾的空字符。
# 返回：返回被去掉空格的字符串值。
# 示例：$(strip ' ' a b c ' ')
# 把字串 ' ' a b c ' ' 去到开头和结尾的空格，结果是a b c。

# $(findstring <find>,<in>)
# 名称：查找字符串函数
# 功能：在字串 <in> 中查找 <find> 字串。
# 返回：如果找到，那么返回 <find> ，否则返回空字符串。
# 示例：$(findstring a,a b c) # 返回 a 字符串
#      $(findstring a,b c) # 返回空字符串

# $(filter <pattern...>,<text>)
# 名称：过滤函数
# 功能：以 <pattern> 模式过滤 <text> 字符串中的单词，保留符合模式 <pattern> 的单词。可以有多个模式。
# 返回：返回符合模式 <pattern> 的字串。
# 示例：sources := foo.c bar.c baz.s ugh.h
#      foo: $(sources)
#	   cc $(filter %.c %.s,$(sources)) -o foo # 返回的值是 foo.c bar.c baz.s 。
 
# $(filter-out <pattern...>,<text>)
# 名称：反过滤函数
# 功能：以 <pattern> 模式过滤 <text> 字符串中的单词，去除符合模式 <pattern> 的单词。可以有多个模式。
# 返回：返回不符合模式 <pattern> 的字串。
# 示例：objects=main1.o main2.o foo.o bar.o
#	   mains=main1.o main2.o
# 	   $(filter-out $(mains),$(objects)) 返回值是 foo.o bar.o 。

# $(sort <list>)
# 名称：排序函数
# 功能：给字符串 <list> 中的单词排序（升序）。
# 返回：返回排序后的字符串。
# 示例：$(sort foo bar lose) 返回 bar foo lose。
# 备注：sort 函数会去掉 <list> 中相同的单词。

# $(words <text>)
# 名称：单词个数统计函数
# 功能：统计 <text> 中字符串中的单词个数。
# 返回：返回 <text> 中的单词数。
# 示例：$(words, foo bar baz) 返回值是 3 。

# $(word <n>,<text>)
# 名称：取第<n>单词函数
# 功能：取字符串 <text> 中第 <n> 个单词。（从一开始）
# 返回：返回字符串 <text> 中第 <n> 个单词。如果 <n> 比 <text> 中的单词数要大，那么返回空字符串。
# 示例：$(word 2, foo bar baz) 返回值是 bar 。
# 备注：如果要取 <text> 中最后的一个单词，可以这样：$(word $(words <text>),<text>) 。

# $(wordlist <ss>,<e>,<text>)
# 名称：取单词串函数
# 功能：从字符串 <text> 中取从 <ss> 开始到 <e> 的单词串。<ss> 和 <e> 是一个数字。
# 返回：返回字符串 <text> 中从 <ss> 到 <e> 的单词字串。
# 如果 <ss> 比 <text> 中的单词数要大， 那么返回空字符串。
# 如果 <e> 大于 <text> 的单词数，那么返回从 <ss> 开始，到 <text> 结束的单词串。
# 示 例 ：$(wordlist 2, 3, foo bar baz) 返 回 值 是 bar baz 。

# $(firstword <text>)
# 名称：取首单词函数
# 功能：取字符串 <text>  中的第一个单词。
# 返回：返回字符串 <text>  的第一个单词。
# 示例：$(firstword foo bar) 返回值是 foo。
# 备注：这个函数可以用 word 函数来实现：$(word 1,<text>) 。

###################### 文件名操作函数 #######################
# $(dir <names...>)
# 名称：取目录函数。
# 功能：从文件名序列 <names> 中取出目录部分。目录部分是指最后一个反斜杠（/ ）之前的部分。如果没有反斜杠，那么返回 ./ 。
# 返回：返回文件名序列 <names> 的目录部分。
# 示例：$(dir src/foo.c hacks) 返回值是 src/ ./ 。

# $(notdir <names...>)
# 名称：取文件函数。
# 功能：从文件名序列 <names> 中取出非目录部分。非目录部分是指最後一个反斜杠（/ ）之后的部分。
# 返回：返回文件名序列 <names> 的非目录部分。
# 示例: $(notdir src/foo.c hacks) 返回值是 foo.c hacks 。

# $(suffix <names...>)
# 名称：取后缀函数。
# 功能：从文件名序列 <names> 中取出各个文件名的后缀。
# 返回：返回文件名序列 <names> 的后缀序列，如果文件没有后缀，则返回空字串。
# 示例：$(suffix src/foo.c src-1.0/bar.c hacks) 返回值是 .c .c。

# $(basename <names...>)
# 名称：取前缀函数。
# 功能：从文件名序列 <names> 中取出各个文件名的前缀部分。
# 返回：返回文件名序列 <names> 的前缀序列，如果文件没有前缀，则返回空字串。
# 示例：$(basename src/foo.c src-1.0/bar.c hacks) 返回值是 src/foo src-1.0/bar hacks 。
 
# $(addsuffix <suffix>,<names...>)
# 名称：加后缀函数。
# 功能：把后缀 <suffix> 加到 <names> 中的每个单词后面。
# 返回：返回加过后缀的文件名序列。
# 示例：$(addsuffix .c,foo bar) 返回值是 foo.c bar.c 。

# $(addprefix <prefix>,<names...>)
# 名称：加前缀函数。
# 功能：把前缀 <prefix> 加到 <names> 中的每个单词后面。
# 返回：返回加过前缀的文件名序列。
# 示例：$(addprefix src/,foo bar) 返回值是 src/foo src/bar 。

# $(wildcard PATTERN)
# 在Makefile规则中，通配符会被自动展开。但在变量定义和函数引用时,通配符将失效。但可以使用wildcard()函数来完成通配符的使用。
# 在Makefile中,它被展开为已经存在的、使用空格分开的、匹配此模式的所有文件列表.如果不存在任何符合此模式的文件，函数会忽略模式字符并返回空。

# $(join <list1>,<list2>)
# 名称：连接函数。
# 功能：把 <list2> 中的单词对应地加到 <list1> 的单词后面。
# 如果 <list1> 的单词个数要比 <list2> 的多，那么，<list1> 中的多出来的单词将保持原样。
# 如果 <list2> 的单词个数要比 <list1> 多，那么，<list2> 多出来的单词将被复制到 <list1> 中。
# 返回：返回连接过后的字符串。
# 示 例 ：$(join aaa bbb , 111 222 333) 返 回 值 是 aaa111 bbb222 333 。

###################### 函数 #######################
# $(foreach <var>,<list>,<text>)
# foreach 函数和别的函数非常的不一样。因为这个函数是用来做循环用的，
# Makefile 中的 foreach 函数几乎是仿照于 Unix 标准 Shell（/bin/sh）中的 for 语句，或是 C-Shell（/bin/csh）中的 foreach 语句而构建的。
# 这个函数的意思是，把参数 <list> 中的单词逐一取出放到参数 <var> 所指定的变量中，然后再执行 <text> 所包含的表达式。
# 每一次执行<text>会返回一个字符串，循环过程中， <text> 的所返回的每个字符串会以空格分隔，
# 最后当整个循环结束时，<text> 所返回的每个字符串所组成的整个字符串（以空格分隔）将会是 foreach 函数的返回值。
# 所以，<var> 最好是一个变量名，<list> 可以是一个表达式，而 <text> 中一般会使用 <var> 这个参数来依次枚举 <list> 中的单词。
# 举个例子：
# 	names := a b c d
# 	files := $(foreach n,$(names),$(n).o)
# 上面的例子中，$(name) 中的单词会被 挨个取出，并存到变量 n 中，每次根据$(n).o 计算出一个值，这些值以空格分隔，
# 最后作为 foreach 函数的返回，所以，$(files) 的值是 a.o b.o c.o d.o。
# 注意，foreach 中的 <var> 参数是一个临时的局部变量，foreach 函数执行完后，参数 <var> 的变量将不在作用，其作用域只在 foreach 函数当中。

# $(if <condition>,<then-part>) 或 $(if <condition>,<then-part>,<else-part>)
# 如果 <condition> 为真（非空字符串），那个 <then-part> 会是整个函数的返回值，
# 如果 <condition> 为假（空字符串），那么 <else-part> 会是整个函数的返回值，
# 此时如果<else-part> 没有被定义，那么，整个函数返回空字串。

# $(call <expression>,<parm1>,<parm2>,...,<parmn>)
# call 函数是唯一一个可以用来创建新的参数化的函数。
# 你可以写一个非常复杂的表达式，这个表达式中，你可以定义许多参数，
# 然后你可以 call 函数来向这个表达式传递参数。
# 当 make 执行这个函数时，<expression> 参数中的变量，
# 如 $(1) 、$(2) 等，会被参数 <parm1> 、<parm2> 、<parm3> 依次取代。
# 而 <expression> 的返回值就是 call 函数的返回值。
# 例如：
# 	reverse = $(1) $(2)
# 	foo = $(call reverse,a,b)
# 那么， foo 的值就是 a b 。当然，参数的次序是可以自定义的，不一定是顺序的，如：
# 	reverse = $(2)+$(1)
# 	foo = $(call reverse,a,b)
# 此时的 foo 的值就是 b+a 。
# 需要注意：在向 call 函数传递参数时要尤其注意空格的使用。
# call 函数在处理参数时，第 2 个及其之后的参数中的空格会被保留，因而可能造成一些奇怪的效果。
# 因而在向 call 函数提供参数时，最安全的做法是去除所有多余的空格。

# $(origin <variable>)
# origin 函数不像其它的函数，他并不操作变量的值，他只是告诉你的这个变量是哪里来的？
# 注意，<variable> 是变量的名字，不应该是引用。所以你最好不要在 <variable> 中使用 $ 字符。
# origin 函数会以其返回值来告诉你这个变量的“出生情况”。
# origin 函数的返回值:
# 	undefined 	如果 <variable> 从来没有定义过。
#	default 	如果 <variable> 是一个默认的定义，比如“CC”这个变量。
# 	environment 如果 <variable> 是一个环境变量，并且当 Makefile 被执行时，-e 参数没有被打开。
# 	file 		如果 <variable> 这个变量被定义在 Makefile 中。
# 	command line 如果 <variable> 这个变量是被命令行定义的。
# 	override  	如果 <variable> 是被 override 指示符重新定义的。
# 	automatic 	如果 <variable> 是一个命令运行中的自动化变量。关于自动化变量将在后面讲述。
# 这些信息对于我们编写 Makefile 是非常有用的，
# 例如，假设我们有一个 Makefile 其包了一个定义文件 Make.def，
# 在 Make.def 中定义了一个变量“bletch”，
# 而我们的环境中也有一个环境变量“bletch”，
# 此时，我们想判断一下，如果变量来源于环境，那么我们就把之重定义了，
# 如果来源于 Make.def 或是命令行等非环境的，那么我们就不重新定义它。
# 于是，在我们的 Makefile 中，我们可以这样写：
# ifdef bletch
# 	ifeq "$(origin bletch)" "environment"
# 		bletch = barf, gag, etc.
# 	endif
# endif
# 当然，你也许会说，使用 override 关键字不就可以重新定义环境中的变量了吗？
# 为什么需要使用这样的步骤？
# 用 override 是可以达到这样的效果，可是 override 过于粗暴，它同时会把从命令行定义的变量也覆盖了,
# 而我们只想重新定义环境传来的，而不想重新定义命令行传来的。

# $(error <text ...>)
# 产生一个<text ...> 错误信息，让 make 停止执行。
# 示例一：
# 	ifdef ERROR_001
# 		$(error error is $(ERROR_001))
# 	endif
# 示例二：
# 	ERR = $(error found an error!)
# 	.PHONY: err
# 	err: $(ERR)
# 示例一会在变量 ERROR_001 定义了后执行时产生 error 调用，而示例二则在目录 err 被执行时才发生 error 调用。
 
# $(warning <text ...>)
# 不会让 make 退出，只是输出一段警告信息，而 make 继续执行。
 
######################################################

#  ======  编译选项  ====== gcc / g++ 参数
# ------------------------------------------------------
# -g: 在编译的时候，产生调试信息。
#     Debug 版本默认只有一个 -g 选项，包含调试信息
# -gstabs: 以 stabs 格式声称调试信息,不包含 gdb 调试信息.
# -gstabs+:　以 stabs 格式声称调试信息,包含 gdb 调试信息.
# -ggdb: 将尽可能的生成 gdb 的可以使用的调试信息.
# ------------------------------------------------------
# -w: 不生成任何警告信息
# -Wall: 选项可以 打印出 编译时所有的错误或者警告 信息。
#     这个选项很容易被遗忘，编译的时候，没有错误或者警告提示，
#     以为自己的程序很完美，其实有可能隐藏着许多陷阱: 变量没有初始化、
#     类型不匹配、类型转换错误等警告提示需要重点注意。
#     没有使用的变量也需要注意，去掉无用的代码，让整个程序显得干净一点。
# ------------------------------------------------------
# -O: 编译器工具链 gcc / g++ 的优化级别: 默认优化级别为零，选项 -O 或 -O0（根本不提供优化）
#     -O0: 表示编译时没有优化。默认
#     -O1: 表示编译时使用默认优化。
#     -Os: 相当于 -O1.5 优化
#     -O2: 表示编译时使用二级优化。
#     -O3: 表示编译时使用最高级优化。Release 版本默认 -O3 选项
# ------------------------------------------------------
# -x [language] [filename]
#     设定文件所使用的语言,使后缀名无效,对以后的多个源文件或头文件有效。
#     也就是根据约定C语言的后缀名称是.c的，而C++的后缀名是.C或者.cpp,
#     用这个参数决定你的C代码文件的后缀名，如 mycpp.zcq 。
#     [language]: c, objective-c, c-header, c++, cpp-output, assembler, assembler-with-cpp.
#     [filename]: 源文件或头文件。
#     例子: gcc -x c hello.pig   // hello.c -> hello.pig
# -x none [filename]
# 　　关掉上一个选项( -x [language] [filename] )，也就是根据文件名后缀，自动识别文件类型
#     例子: gcc -x c hello.pig -x none hello2.c
# ------------------------------------------------------
# -S: 只激活预处理和编译，就是指把文件编译成为汇编代码。
#     例子: gcc -S hello.c  // 将生成 .s 的汇编代码
# ------------------------------------------------------
# -E: 只激活预处理,这个不生成文件, 你需要把它重定向到一个输出文件里面。
#     例子: gcc -E hello.c > pianoapan.txt
#           gcc -E hello.c | more
# ------------------------------------------------------
# -o [file.exe]: 生成可执行文件,缺省的时候,gcc 编译出来的文件是 a.out
#     例子: gcc -o hello.exe hello.c (哦,windows用习惯了)
#     　    gcc -S hello.c -o hello.asm
# ------------------------------------------------------
# -pipe: 使用管道代替编译中临时文件,在使用 非gnu 汇编工具的时候,可能有些问题
#     例子: gcc -pipe hello.c -o hello.exe
# ------------------------------------------------------
# -ansi: 关闭 gnu c 中与 ansi c 不兼容的特性,激活 ansi c 的专有特性
#     (包括禁止一些 asm inline typeof 关键字,以及 UNIX,vax 等预处理宏,
# -fno-asm: 此选项实现 -ansi 选项功能的一部分，它禁止将 asm,inline 和 typeof 用作关键字。
# ------------------------------------------------------
# -fno-strict-prototype: 只对 g++ 起作用,使用这个选项,g++ 将对不带参数的函数,
#     都认为是没有显式的对参数的个数和类型说明,而不是没有参数.
#     而 gcc 无论是否使用这个参数,都将对没有带参数的函数,认为是没有显式说明的类型
# ------------------------------------------------------　　
# -fthis-is-varialble: 就是向传统 c++ 看齐,可以使用 this 当一般变量使用.
# ------------------------------------------------------
# -fcond-mismatch: 允许条件表达式的第二和第三参数类型不匹配,表达式的值将为 void类型
# ------------------------------------------------------
# -funsigned-char 、-fno-signed-char、-fsigned-char 、-fno-unsigned-char
#     这四个参数是对 char 类型进行设置,
#     决定将 char 类型设置成 unsigned char(前两个参数)或者 signed char(后两个参数)。
# ------------------------------------------------------
# -include [filename]: 功能相当于在代码中使用 #include<filename>
#     例子: gcc hello.c -include /usr/include/stdio.h -o hello.exe
# ------------------------------------------------------
# -imacros [file]: 将 file 文件的宏, 扩展到 gcc/g++ 的输入文件,
#     宏定义本身并不出现在输入文件中。　　
# ------------------------------------------------------
# -Dmacro: 相当于 C 语言中的 #define macro
# -Dmacro=defn: 相当于 C 语言中的 #define macro=defn
# -Umacro: 相当于 C 语言中的 #undef macro
# -undef: 取消对任何非标准宏的定义
# ------------------------------------------------------
# -M: 生成文件关联的信息（目标文件所依赖的所有源代码）
#     可以用 gcc -M hello.c 来测试一下。
# -MM: 和 -M 相同，但忽略由 #include<file> 造成的依赖关系。
# -MD: 和 -M 相同，但输出将导入到 .d 的文件里面　
# -MMD: 和 -MM 相同，但输出将导入到 .d 的文件里面
# ------------------------------------------------------
# -Idir: 头文件的搜索路径，
#     用 #include "file.h" 的时候,gcc/g++会先在 当前目录 dir 查找自定义头文件，
#     如果没有找到，再按常规的顺序去找。
# -I-: 取消前一个参数的功能,所以一般在 -Idir 之后使用
# -idirafter dir: 在 -I 的 dir 目录 查找失败，就到 这个目录 dir 里面查找。
# -iprefix prefix, -iwithprefix dir: 一般一起使用，
#      在 -I 的 dir 目录 查找失败,会到 prefix + dir 下查找
# -nostdinc: 使编译器不再系统缺省的头文件目录里面找头文件,
#     一般和-I联合使用,明确限定头文件的位置
# ------------------------------------------------------
# -c: 只激活预处理,编译,和汇编,也就是他只把程序做成 obj 文件
#     例子: gcc -c hello.c  // 将生成 hello.o 的 obj 文件
# ------------------------------------------------------
# -C: 预处理时保留注释信息,不删除注释信息,一般和-E使用,有时候分析程序，用这个很方便的
# ------------------------------------------------------
# -m32, -m64: 生成32/64位的 动态/静态 链接库
# ------------------------------------------------------
# -fPIC(或fpic): 生成使用相对地址无关的目标代码
# ------------------------------------------------------
# -static: 强制所有的库都使用静态库版本，禁止使用动态库
# -shared: 进行动态库编译，链接动态库
# ------------------------------------------------------
# -llibrary: 制定编译的时候使用的库
# 　　例子: gcc -lpthread          hello.c -o hello.exe
# -lname: 链接 静态库(libname.a)或 动态库(libname.so)的库文件
# -Ldir: 制定编译的时候，搜索库的路径。
#     比如你自己的库，可以用它制定目录，不然编译器将只在标准库的目录找。
# 　　例子: gcc -L/usr/local/lib   hello.c -o hello.exe
# ------------------------------------------------------
# 编译器 g++ 与 gcc 的使用是相通的
# ------------------------------------------------------
# 动态库 ( Windows: *.dll ; Linux : *.so ) 是在运行时动态加载，当删除库文件时会报错
# 使用 gcc 生成 动态库 及 使用动态库 的方法:
# 第一步：生成
#     方法一: 将生成 zcq.o 的 obj 文件，再使用 -shared 参数 生成 动态库
#            gcc -c zcq.c
#            gcc -shared -fPIC  zcq.o  -o libzcq.so
#     方法二：使用 -shared 参数 生成 动态库
#            gcc -shared -fPIC  zcq.c  -o libzcq.so
# 第二步：使用
#     方法一：把 libzcq.so 复制到 /usr/lib64/ 系统路径下
#            注意：生成的动态库的名字必须是 lib+名字.so，之后可以直接使用 -lzcq 来引用动态库。
#            编译 main.c，使用 libzcq.so 动态库
#            gcc -L/usr/lib64/ -lzcq    main.c -o main
#     方法二：直接使用 当前目录下的 libtest.so 文件,
#            编译 main.c，链接 libtest.so 的时候，
#            gcc ./lib/libzcq.so        main.c -o main
#            gcc -L./lib       -lzcq    main.c -o main
# 注意：当编译链接完生成可执行文件后，在运行时会出现 "无法找到 libzcq.so" 等类似错误，
# g++ 在链接时搜索到 第三方库时，链接成功。但是在执行过程中，当调用相应的外部函数时，
# 程序再一次会 去找第三方库，因为默认搜索目录没有，所以会出现找不到库的情况。
# 这时需要我们修改编译链接命令：
#     g++  *.cpp  -I./include/  -L./lib  -lzcq  -Wl,-rpath=./  -o main
# -Wl,-rpath=“具体目录”，将第三方库路径显性加入程序运行时搜索目录
# ------------------------------------------------------
# 静态库 ( Windows: *.lib ; Linux : *.a ) 是在链接的时候直接把库文件复制到程序中，
#     运行的时候不再依赖库文件
# 使用 gcc 生成 静态库 及 使用静态库 的方法:
# 第一步：生成
#     方法一: 将生成 zcq.o 的 obj 文件，再将 obj 文件 生成 libzcq.a 静态库
#            gcc -c  zcq.c
#            ar  -crv  libzcq.a   zcq.o
#     方法二：生成 libzcq.a 静态库
#            gcc  -fPIC  zcq.c  -o libzcq.a
# 第二步：使用
#        gcc  -L./lib  -lzcq   main.c -o main
# ------------------------------------------------------
# 添加 c++17 std::thread 的方法 :
# gcc               -Wall -g sctp_service.c            -lrt   -lsctp   -o main
# gcc 前面 编译选项: -Wall -g sctp_service.c  后面 编译选项: -lsctp   -o main
#/usr/lib/x86_64-linux-gnu/libsctp.a
#/usr/lib/x86_64-linux-gnu/libsctp.so.1.0.18

######################################################

# 在 Unix 世界中，软件发布时，特别是 GNU 这种开源软件的发布时，
# 其 makefile 都包含了编译、安装、打包等功能。
# 我们可以参照这种规则来书写我们的 makefile 中的目标。
# all: 		这个伪目标是所有目标的目标，其功能一般是编译所有的目标。
# clean: 	这个伪目标功能是删除所有被 make 创建的文件。
# install: 	这个伪目标功能是安装已编译好的程序，其实就是把目标执行文件拷贝到指定的目标中去。
# print: 	这个伪目标的功能是例出改变过的源文件。
# tar: 		这个伪目标功能是把源程序打包备份。也就是一个 tar 文件。
# dist: 	这个伪目标功能是创建一个压缩文件，一般是把 tar 文件压成 Z 文件。或是 gz 文件。
# TAGS: 	这个伪目标功能是更新所有的目标，以备完整地重编译使用。
# check 和 test: 这两个伪目标一般用来测试 makefile 的流程。

